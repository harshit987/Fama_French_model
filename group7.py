# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11RPV9Wqk0K_zCqgmJ6EJkdj-v4nGBUeh
"""

import pandas as pd
from operator import itemgetter

# from google.colab import drive
# drive.mount('/content/drive')

data=pd.read_csv("CE_China.csv")
df=data.drop(data.columns[1:7],axis=1)
# df=df.loc[df['Name'][::-1]>='2013/01/28']
# df=df.loc[df['Name'][::-1]<='2018/12/28']
# df.head(10)
df=df.iloc[99:171,:]
df

import numpy as np
import math
# from google.colab import files
def avg(list):
  list=np.array(list)
  return np.sum(list)/len(list)
def intersection(lst1, lst2): 
    lst3 = [value for value in lst1 if value in lst2] 
    return lst3 
def isNaN(x):
    return str(float(x)).lower() == 'nan'
def get_smb_hml(df,row):
  total=0
  cnt=0
  m_cap_list=[]
  roe_list=[]
  return_list=[]
  idx=0
  z=df.iloc[row] 
  z1=df.iloc[row-1]
  for i in range(int((len(df.columns)-1)/3)):
    total=total+1 
    m_cap=z[3*i+1]
    roe=z[3*i+2]
    price_t=z[3*i+3]
    price_t_1=z1[3*i+3]
    if not isNaN(m_cap) and not isNaN(roe) and not isNaN(price_t) and not isNaN(price_t_1):
      m_cap_list.append((m_cap,idx))
      roe_list.append((roe,idx))
      ret=(math.log(price_t/price_t_1))*100
      return_list.append(ret)
      idx=idx+1
      cnt=cnt+1

  m_cap_list=sorted(m_cap_list,key=itemgetter(0))
  roe_list=sorted(roe_list,key=itemgetter(0))
  # print(m_cap_list)
  # print(roe_list)

  small=m_cap_list[0:int(len(m_cap_list)/2)]
  small_i=[b for (a,b) in small]
  big=m_cap_list[int(len(m_cap_list)/2):int(len(m_cap_list))]
  big_i=[b for (a,b) in big]
  growth=roe_list[0:int(len(roe_list)*0.3)]
  growth_i=[b for (a,b) in growth]
  neutral=roe_list[int(len(roe_list)*0.3):int(len(roe_list)*0.7)]
  neutral_i=[b for (a,b) in neutral]
  value=roe_list[int(len(roe_list)*0.7):int(len(roe_list))]
  value_i=[b for (a,b) in value]
  # print(small_i)
  # print(value_i)

  sv=intersection(small_i,value_i)
  sn=intersection(small_i,neutral_i)
  sg=intersection(small_i,growth_i)
  bv=intersection(big_i,value_i)
  bn=intersection(big_i,neutral_i)
  bg=intersection(big_i,growth_i)
  # print(sv)
  sv_return_list=[return_list[i] for i in sv]
  # print(price_list[324])
  sn_return_list=[return_list[i] for i in sn]
  sg_return_list=[return_list[i] for i in sg]
  bv_return_list=[return_list[i] for i in bv]
  bn_return_list=[return_list[i] for i in bn]
  bg_return_list=[return_list[i] for i in bg]
  sv_return=avg(sv_return_list)
  sn_return=avg(sn_return_list)
  sg_return=avg(sg_return_list)
  bv_return=avg(bv_return_list)
  bn_return=avg(bn_return_list)
  bg_return=avg(bg_return_list)

  # for i in df.iloc[0]:
  sml=0.33*(sv_return+sn_return+sg_return)-0.33*(bv_return+bn_return+bg_return)
  hml=0.5*(sv_return+bv_return)-0.5*(sg_return+bg_return)  
  # print(sml,hml)
  return [sml,hml]
data=[]

for i in range(1,72):
  x=get_smb_hml(df,i)
  x.insert(0,df.iloc[i,0])
  price_t=df.iloc[i,3]
  price_t_1=df.iloc[i-1,3]
  ret=(math.log(price_t/price_t_1))*100
  x.append(ret)
  data.append(x)
  
# print(data)
df1 = pd.DataFrame(data, columns = ['Date', 'SMB','HML','Return_of_INDUSTRIAL AND COMM']) 
print(df1.head(10))

df1.to_csv('regression_data.csv')
# files.download('regression_data.csv')

def get_momentum_factor(df,row):
  total=0
  cnt=0
  m_cap_list=[]
  return_list=[]
  return11_list=[]
  idx=0
  z=df.iloc[row] 
  z1=df.iloc[row-1]
  tm1=df.iloc[row-1]
  tm12=df.iloc[row-12]

  for i in range(int((len(df.columns)-1)/3)):
    total=total+1 
    m_cap=z[3*i+1]
    price_t=z[3*i+3]
    price_t_1=z1[3*i+3]
    price_tm1=tm1[3*i+3]
    price_tm12=tm12[3*i+3]

    if not isNaN(m_cap) and not isNaN(price_tm1) and not isNaN(price_tm12) and not isNaN(price_t) and not isNaN(price_t_1):
      m_cap_list.append((m_cap,idx))
      ret=(math.log(price_t/price_t_1))*100
      return_list.append((ret,idx))
      ret_11=(math.log(price_tm1/price_tm12))*100
      return11_list.append((ret_11,idx))
      idx=idx+1
      cnt=cnt+1

  m_cap_list=sorted(m_cap_list,key=itemgetter(0))
  momentum_return=sorted(return11_list,key=itemgetter(0))
  loser=momentum_return[0:int(len(momentum_return)*0.3)]
  winner=momentum_return[int(len(momentum_return)*0.7):int(len(momentum_return))]
# mycode



  small=m_cap_list[0:int(len(m_cap_list)/2)]
  small_i=[b for (a,b) in small]
  big=m_cap_list[int(len(m_cap_list)/2):int(len(m_cap_list))]
  big_i=[b for (a,b) in big]
  # print(small_i)
  # print(value_i)

# mycode
  winner_index=[b for (a,b) in winner]
  loser_index=[b for (a,b) in loser]

  # print(big_i)
  # print(winner_index)

  WB=intersection(big_i,winner_index)
  WS=intersection(small_i,winner_index)
  LB=intersection(big_i,loser_index)
  LS=intersection(small_i,loser_index)

  # print(WB)

  WS_VALUE=[a for (a,b) in return_list if b in WS]
  WB_VALUE=[a for (a,b) in return_list if b in WB]
  LS_VALUE=[a for (a,b) in return_list if b in LS]
  LB_VALUE=[a for (a,b) in return_list if b in LB]

  WS_VALUE=avg(WS_VALUE)
  WB_VALUE=avg(WB_VALUE)
  LS_VALUE=avg(LS_VALUE)
  LB_VALUE=avg(LB_VALUE)


  return (WS_VALUE-LS_VALUE+WB_VALUE-LB_VALUE)/2;


data=[]

for i in range(13,72):
  # print(i)
  x=[get_momentum_factor(df,i)]
  x.insert(0,df.iloc[i,0])
  # print(x)
  data.append(x)
  
# print(data)
df2 = pd.DataFrame(data, columns = ['Date', 'Momentum_Factor']) 
print(df2.head(10))

df2.to_csv('momentum_factor_data.csv')
# files.download('momentum_factor_data.csv')

